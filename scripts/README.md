# Elements

## Toolchain.py

Takes as input a model or a model poset. If the input is a model, the toolchain invokes Poly2Poset and transforms the input into a model poset.
The poset is then encoded into an LTS: the procedure produces a MCRL2 file.

The MCRL2 file is then transformed into an LPS. As states' labels are recreated during the encoding process, we generate an LPSpp (pretty print) file, that allows us to enstablish a correspondence between the original states' labels and the new ones. In order to do this:
* we add a self loop with the state name to every state in the form st_(state_label);
* we produce the lpspp;
* we check for lines starting with st to recover the state label and get the correspondent inner state.

In order to preserve minimisation, all the self loops labelled with the state names must be removed. We thus invoke the renamelps command to transform all these self loops into tau transitions. These will be removed by minimising the LTS.

We now produce the minimised LTS and create JSon files that serve as input for the PolyVisualiser. Finally, we create a LaTeX table containing execution times.

Recap: in order to get a minimised model, the user must only provide a model file (in JSon format) OR a model poset file (also in JSon format) and a filename with *.tex extension, indicating the latex table to be generated at the end of the process.

Output files are organised in subfolders. /toolchain_output contains all the intermediate files, plus two subfolders:
* minimised_model contains the minimised output;
* classes contains the JSon files in the PolyVisualiser format.

## Model checking

The minimised model, called polyInput_Poset.json, can be provided to the model checker as an input. It already represents a reflexive Kripke structure, then no further operations are needed. The result generated by the model checker is again a JSon file in the PolyVisualiser format, but the number of elements is the same as the number of classes. As PolyVisualiser requires as input a color file, an atom file and a model file, it is necessary to allign the number of states of the result file with the number of states of the model files.

## ResultTransformer.py

In order to get a result file containing the right number of states, we wrote a resultTransformer script. It takes as input the result of the model checking procedure and the JSon files generated by the toolchain. The script parses the results and computes the or of all the classes where a formula is true, recovering them from the JSon files. The obtained files, stored in the folder /toolchain_output/results, can be now used to visualise the result of the model checking procedure in PolyVisualiser.

# Running example: triangle

## Minimise the triangle

Explain triangle minimisation.

## Model check the minimised model

Explain model checking phase.

## Transform and compare results

Explain how one can transform the results to visualise them using the polyVisualiser.