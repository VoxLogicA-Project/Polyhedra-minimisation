# Eta minimisation

This artifact contains all the files and scripts needed in order to reproduce the results shown in the paper. Experiments consist of two separated steps:
    1: the minimisation step, where the original model is translated into a poset and minimised;
    2: the model checking step, where model checking is performed over the minimised model.
In the follwing, we explain in details how to reproduce results and visualise them, using the triangleRB experiment as a running example.

## PolyVisualiser

In order to visualise results obtained running the two steps, we provide users with a PolyVisualiser. The PolyVisualiser accepts as input a model (in the json format), a colour file
listing all atomic propositions contained in the model and and atom file, containing truth values of atomic propositions and possibly formulas.
In order to launch the PolyVisualiser webapp it suffices to access the application folder, open a terminal and launch a server. For instance, using php, you can run the following
command:
    php -S localhost:5000
and open a browser to the page 127.0.0.1:5000/polyVisualiser.html. Once you have loaded the required files (in our case triangleRBModel.json, triangleRBColors.json, triangleRBAtoms.json),
you will be able to visualise the model and its properties. Using the Property menu, and selecting the Show Property option, it will be possible to visualise where different atomic 
propositions hold.

## Minimisation

Minimisation of the model is performed by the toolchain.py script, that takes as an input a model file. In order to run the script, one must access the experiment folder and run it
from command line. In our example:
    cd experiments/triangleRB
    ../../scripts/toolchain.py triangleRBModel.json
The result of the execution will be a json file containing a dictionary of the equivalence classes, in the form array of booleans. The length of each array corresponds to the number of
states of the original poset model: let classX be the array of booleans representing the class labelled with X, classX[i] = True if and only if the state i is included in the class X.
The json file can be loaded in PolyVisualiser as an atom file, in order to graphically visualise the equivalence classes. If there is no model poset file in the experiment folder, the
script generates a model poset file (in the format experimentName_Poset.json) that is needed to perform the encoding as an LTS and that can be used as an input for the model
checker PolyLogicA. In our case, the generated file will be triangleRBModel_Poset.json.
Moreover, the toolchain script generates a polyInput_Poset.json file, containing the minimised model poset. It is possible to run model checking on this minimised model, and to 
compare results with those obtained by performing model checking on the original model.

## Model checking

As said, the model checker PolyLogicA accepts as an input a model poset file, plus an imgql specification. It is possible to run analysis on both the original and the minimised model
(in our example, triangleRBModel_Poset.json and polyInput_Poset.json). The folder of PolyLogicA contains an imgql specification, named triangleRBSpec.imgql, that can be used and 
modified to run analysis. In order to perform this step, one must use the following commands:
    mv triangleRBModel_Poset.json polyInput_Poset.json ../PolyLogicA
    cd ../PolyLogicA
    ./bin/release/net8.0/linux-x64/PolyLogicA triangleRBSpec.imgql
The execution of these commands generates a file named result.json, again containing json arrays of booleans. Being prop the array representing the property prop, prop[i] = True if
and only if the property prop is true at state i.
While the result file generated by running analysis on the original model poset has the same number of states as the original model, this is not the case for the result file
generated by running analysis on the minimised model. To overcome this issue, we provide users with a resultTransform.py script, that takes care of align the number of states of 
the result file with that of the original model, in such a way that it is possible to use results as an atom file in the polyVisualiser. The resultTransform script takes as input 
the directory containing the jsonOutputAll.json file and the result file from the model checker. In our case:
    cd ../experiments/triangleRB
    mv ../PolyLogicA/result.json .
    python3 resultTransform.py toolchain_output/classes result.json
The script creates a directory results containing the file originalResults.json, namely an atom file whose size is compatible with that of the original poset model, and that thus can
be used as an atom file in the PolyVisualiser. It is hence possible to compare the results of the model checking procedure on both the original model and the minimised one.

## Easy procedure

In order to ease the process, we also provide a python script that performs all the aforementioned steps. This can be invoked as follows:
    cd scripts
    python3 minimisedExperiments.py
The script performs all the aforementioned steps (except the visualisation in PolyVisualiser) for the maze test suite, namely 3x3x3, 3x5x3, 3x5x4, 5x5x5.

# Elements

## Toolchain.py

Takes as input a model or a model poset. If the input is a model, the toolchain invokes Poly2Poset and transforms the input into a model poset.
The poset is then encoded into an LTS: the procedure produces a MCRL2 file.

The MCRL2 file is then transformed into an LPS. As states' labels are recreated during the encoding process, we generate an LPSpp (pretty print) file, that allows us to enstablish a correspondence between the original states' labels and the new ones. In order to do this:
* we add a self loop with the state name to every state in the form st_(state_label);
* we produce the lpspp;
* we check for lines starting with st to recover the state label and get the correspondent inner state.

In order to preserve minimisation, all the self loops labelled with the state names must be removed. We thus invoke the renamelps command to transform all these self loops into tau transitions. These will be removed by minimising the LTS.

We now produce the minimised LTS and create JSon files that serve as input for the PolyVisualiser. Finally, we create a LaTeX table containing execution times.

Recap: in order to get a minimised model, the user must only provide a model file (in JSon format) OR a model poset file (also in JSon format) and a filename with *.tex extension, indicating the latex table to be generated at the end of the process.

Output files are organised in subfolders. /toolchain_output contains all the intermediate files, plus two subfolders:
* minimised_model contains the minimised output;
* classes contains the JSon files in the PolyVisualiser format.

## ResultTransformer.py

In order to get a result file containing the right number of states, we wrote a resultTransformer script. It takes as input the result of the model checking procedure and the JSon files generated by the toolchain. The script parses the results and computes the or of all the classes where a formula is true, recovering them from the JSon files. The obtained files, stored in the folder /toolchain_output/results, can be now used to visualise the result of the model checking procedure in PolyVisualiser.

# Running example: triangle

## Minimise the triangle

Explain triangle minimisation.

## Model check the minimised model

Explain model checking phase.

## Transform and compare results

Explain how one can transform the results to visualise them using the polyVisualiser.